SFINAE

![image-20221217131241788](media/image-20221217131241788.png)

**SFINAE - substitution failure is not an error**

![image-20221217131400557](media/image-20221217131400557.png)

непосредственный контекст класса - это может быть декларация. Если ошибка в теле, то это не SFINAE, а ошибка второй фазы.

![image-20221217131546732](media/image-20221217131546732.png)

> Помним: разрешение зависимых имен откладывается до подстановки шаблонного параметра

Из этого можно получить SFINAE:

![image-20221217131727780](media/image-20221217131727780.png)

???

SFINAE используется вместе со специализацией и частичной специализацией.

Пример 1: отображение int-type

Каждому числу сопоставим тип: для каждого int есть type, мы делаем implicit cast типа к ЗНАЧЕНИЮ.

![image-20221217132201021](media/image-20221217132201021.png)

определим некоторые такие интегральные типы:

![image-20221217132744119](media/image-20221217132744119.png)

а теперь запускаем SFINAE:

primary_template:

![image-20221217132859740](media/image-20221217132859740.png)

specialization:

![image-20221217132953977](media/image-20221217132953977.png)

провал подстановки

![image-20221217133246967](media/image-20221217133246967.png)

прослеживается SFINAE триада: *primary, specialization, alias*

![image-20221217133513728](media/image-20221217133513728.png)

![image-20221217133548212](media/image-20221217133548212.png)

![image-20221217132021720](media/image-20221217132021720.png)

![image-20221217133701248](media/image-20221217133701248.png)

Реализуем is_same



# Магистерская часть

Разрешение частичного порядка/ перегрузки

В процессе разрешения имен - вывод типов

Двухфазное разрешение имен

Линкеры исключают неиспользованные функции

Инстанцирование - порождение специализации

Как может провалиться инстанцирование?

Через вывод типов

Через синтакисчески неккоректный контекст

![image-20221217141502251](media/image-20221217141502251.png)

![image-20221217141810861](media/image-20221217141810861.png)

typename для дизамбигуации

Это означает условный переход на этапе компиляции. Т.е. метопрограммирование на уровне инстанцирования.

Пример 2

![image-20221217143640030](media/image-20221217143640030.png)

![image-20221217143040057](media/image-20221217143040057.png)

```C++
#include <concepts>
#include "gtest/gtest.h"

template <typename T> struct has_typedef_foobar {
  using yes = char[1];// для гарантии отработки sizeof во время компиляции
  using no = char[2];
    // две перегрузки (тип С для запуска SFINAE в теле структуры, Т просто подставляется тут уже)
  template <typename C> static yes& test(typename C::foobar*);
    // здесь шаблон, потому что мы в енуме задан шаблонный параметр
    // если в енуме его убрать, то будет другая проблема - не сработает вывод типов: из нуля вывод С не сработает. И в обоих случаях будет выбрана (...)
  template <typename> static no& test(...); // va_args
    // do not require def outside class
  enum { value = (sizeof(test<T>(0)) == sizeof(yes)) };
};

struct foo { using foobar = float; };
struct bar { };

TEST(sfinae, hasfoobar) {   
  EXPECT_EQ(has_typedef_foobar<foo>::value, true);
  EXPECT_EQ(has_typedef_foobar<bar>::value, false);
}
```

https://godbolt.org/z/KPdbjoodM



![image-20221217141251406](media/image-20221217141251406.png)



# Draft

![image-20221217135026715](media/image-20221217135026715.png)

Чтобы определить метод - мы реализуем переключатель

![image-20221217135449436](media/image-20221217135449436.png) 

![image-20221217135535860](media/image-20221217135535860.png)

![image-20221217135902030](media/image-20221217135902030.png)

Перегруженный опрератор *