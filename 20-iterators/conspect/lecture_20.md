# Lecture 20

# Iterators

### Итерационные функции

```С++
std::distance(Iter fst, int n); // snd - fst, либо цикл
std::advance(Iter sat, int n); // fst + n, либо цикл
```

У таких функций, в отличие от интерфейса итераторов, неопределенная асимптотическия сложность.

`prev = std::exchange(cur, cur + prev)` - записать в `cur` новое значение, а старое `cur` выдать в `prev`.

 `std::find_if_not`

> В каких случаях будет вызвана внешняя begin, или `std::begin`?
>
> Если у нас не встроенный массив (наивысший приоритет, в котором начало - адрес первого, а конец - адрес за последним) и не что-то, у чего есть методы begin/end (догадывается о наличии через SFINAE)  и есть внешняя функция.

## ADL (argument depended lookup)

Если функция не может быть найдена в текущем namespace и в охватывающих - она будет искаться в namespace аргументов.

![image-20221216112634432](media/image-20221216112634432.png)

![image-20221216112645824](media/image-20221216112645824.png)

![image-20221216112706309](media/image-20221216112706309.png)

![image-20221216112724884](media/image-20221216112724884.png)

![image-20221216112737090](media/image-20221216112737090.png)

![image-20221216112748582](media/image-20221216112748582.png)

**Итератор - копируемый объект!**

![image-20221216113520933](media/image-20221216113520933.png)

![image-20221216113559931](media/image-20221216113559931.png)

Тут вернется позиция, для которой `func` вернула `false`.



Если не лезть в контейнер, то из-за -1 уровня косвенности будет ускорение по производительности (в 3 раза) - см. `matrix_repro.cc`

**При итерациях по чему-то - нужно передавать пару итераторов.**

![image-20221216113705187](media/image-20221216113705187.png)

У итераторов синтаксически одинаковый интерфейс, за исключением класса характеристик:

![image-20221216114206389](media/image-20221216114206389.png)

Их можно вывести, перегрузив оператор <<

![image-20221216114732691](media/image-20221216114732691.png)

random, forward, bidirect, random, input, output



Как отличить input_iterator от forward_iterator, если у них нет синтаксических различий (т.е. SFINAE не сработает), и есть лишь семантические?

Это решается с помощью тэгов (iterator_category). Они позволяют вынести семантические различия на синтаксический уровень.

Перегрузка по тэгам:

![image-20230115235400662](media/image-20230115235400662.png)

получим вывод типов итераторов на экран.

### Как навесить ограничение на передаваемый тип итератора?

#### Conditional type

```C++
template <bool B, typename T, typename F>
struct conditional { using type = T; }

template <typename T, typename F>
struct conditional<false, T, F> { using type = F; }

template <bool B, typename T, typename F>
using conditional_t = typename conditional<B, T, F>::type;

// если хотим сделать невалидным для F:

template <bool B, typename T = vo id>
struct conditional { using type = T; }

template <typename T = void>
struct conditional<false, T> {}

template <bool B, typename T = void>
using enable_if_t = typename enable_if_t<B, T>::type;

// т.о. конструкция будет невалидной, если B = false, т.к. не будет определен type.
```

Применительно к итераторам это выглядит так:

![image-20230116000446302](media/image-20230116000446302.png)

Итератор помимо iterator_category должен также определять следующие типы:

![image-20230116000810914](media/image-20230116000810914.png)

Например, напишем итератор по паре значений:

![image-20230116001537689](media/image-20230116001537689.png)

![image-20230116001633616](media/image-20230116001633616.png)

Ссылки, потому что массивы заданы извне.

![image-20230116001735463](media/image-20230116001735463.png)

В качестве категории по умолчанию нужно использовать input_iterator.

Порядок реализации:

![image-20230116002049692](media/image-20230116002049692.png)

**Важно! Класс с полями-ссылками требует дефолтного конструктора.**

![image-20230116002513395](media/image-20230116002513395.png)

> Почему value_type - пара значений а не ссылок. Ну, есть тип reference + не всем свойствам значений удовлетворяют ссылки.

 ![image-20230116002916802](media/image-20230116002916802.png)

> Будет ли провисание ссылок при возврате из `operator*()`? Нет, т.к. ссылки ссылаются на внешние массивы. Обращаем внимание, что агрегат в этом операторе выводится к reference type.

Однако не все так просто с ссылками. Например, вектор булов так не сработает. Верное решение:

![image-20230116004509586](media/image-20230116004509586.png)

А что насчет указателей?

Можно определить вот так

```C++
void operator->() const {}
```

Тогда его компилятор рассматривает несуществующим. А если нужна реализация?

![image-20230116004743169](media/image-20230116004743169.png)

Выход из положения - proxy class

![image-20230116005249262](media/image-20230116005249262.png)

Заметим, что класс невладеющий: он хранит ссылку на внешний объект. Естественно, он не провиснет во время создания / удаления прокси-класса.

Zip_range - типичный адаптер.



![image-20221216132200733](media/image-20221216132200733.png)

Как вывести reverse range based?

![image-20221216132610348](media/image-20221216132610348.png)





## Adapters

* inserters (back / front)
* 