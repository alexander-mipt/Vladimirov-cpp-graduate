# Lecture 20

# Iterators

### Итерационные функции

```С++
std::distance(Iter fst, int n); // snd - fst, либо цикл
std::advance(Iter sat, int n); // fst + n, либо цикл
```

У таких функций, в отличие от интерфейса итераторов, неопределенная асимптотическия сложность.

`prev = std::exchange(cur, cur + prev)` - записать в `cur` новое значение, а старое `cur` выдать в `prev`.

 `std::find_if_not`

> В каких случаях будет вызвана внешняя begin, или `std::begin`?
>
> Если у нас не встроенный массив (наивысший приоритет, в котором начало - адрес первого, а конец - адрес за последним) и не что-то, у чего есть методы begin/end (догадывается о наличии через SFINAE)  и есть внешняя функция.

## ADL (argument depended lookup)

Если функция не может быть найдена в текущем namespace и в охватывающих - она будет искаться в namespace аргументов.

![image-20221216112634432](media/image-20221216112634432.png)

![image-20221216112645824](media/image-20221216112645824.png)

![image-20221216112706309](media/image-20221216112706309.png)

![image-20221216112724884](media/image-20221216112724884.png)

![image-20221216112737090](media/image-20221216112737090.png)

![image-20221216112748582](media/image-20221216112748582.png)

**Итератор - копируемый объект!**

![image-20221216113520933](media/image-20221216113520933.png)

![image-20221216113559931](media/image-20221216113559931.png)

Тут вернется позиция, для которой `func` вернула `false`.



Если не лезть в контейнер, то из-за -1 уровня косвенности будет ускорение по производительности (в 3 раза) - см. `matrix_repro.cc`

**При итерациях по чему-то - нужно передавать пару итераторов.**

![image-20221216113705187](media/image-20221216113705187.png)

У итераторов синтаксически одинаковый интерфейс, за исключением класса характеристик:

![image-20221216114206389](media/image-20221216114206389.png)

Их можно вывести, перегрузив оператор <<

![image-20221216114732691](media/image-20221216114732691.png)

random, forward, bidirect, random, input, output



Как отличить input_iterator от forward_iterator, если у них нет синтаксических различий (т.е. SFINAE не сработает), и есть лишь семантические?

Это решается с помощью тэгов (iterator_category).



![image-20221216132200733](media/image-20221216132200733.png)

Как вывести reverse range based?

![image-20221216132610348](media/image-20221216132610348.png)





## Adapters

* inserters (back / front)
* 