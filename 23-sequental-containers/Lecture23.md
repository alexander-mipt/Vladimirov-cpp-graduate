# Lecture 23

# Контейнеры

Лучший контейнер - вектор. Самый часто используемый.

![image-20230318175027319](media/image-20230318175027319.png)

Белые кружки - гарантии по памяти.

Адаптеры - содержат в себе один из контейнеров с специфичным интерфейсом.

## Dequeue

![image-20230318175301922](media/image-20230318175301922.png)

![image-20230318175316932](media/image-20230318175316932.png)

Видно, что из-за релокаций заполнение вектора идет медленнее! Поэтому при заполнении вектора нужно делать `reserve`. 

![image-20230318175548766](media/image-20230318175548766.png)

`Deque` плохо вставляет в середину. Лучше использовать при частых вставках в начало или конец. Также deque плох при обращении к элементам.

![image-20230318175913200](media/image-20230318175913200.png)

![image-20230318175932780](media/image-20230318175932780.png)

> Обратим внимание на интерфейс random. Rand() использует линейный конгруэнтный генератор, которой статистически намного хуже Мейсен-твистора.

 ![image-20230318180319260](media/image-20230318180319260.png)

## Lists

![image-20230318180457589](media/image-20230318180457589.png)

![image-20230318180538052](media/image-20230318180538052.png)

Сплайс может занимать **O(N) в самом сложном случае** и O(1) при вставке в начало или конец. И причина не в перевязке указателей. **Причина в пересчете размера контейнера.**

### Магия сплайсов

В листах вставка производится ровно на то место, на которое указывает итератор

![image-20230318182430535](media/image-20230318182430535.png)

Однако в `forward_list` это не так: при указании на `begin` вставка листа в лист не будет производится в начало. 

![image-20230318192807362](media/image-20230318192807362.png)

Нужно использовать `before_begin`.

![image-20230318192838246](media/image-20230318192838246.png)

![image-20230318192423412](media/image-20230318192423412.png)

**При этом `it` не изменился: он продолжает указывать на число 1. Он не инвалидировался.**

![image-20230318193213179](media/image-20230318193213179.png)

Теперь `second` пустой. Перекинем в него элементы из первого **со второго** (т.к. `begin`, а не `before_begin`) **по итератор на число 1** (***не включительно**,* т.к. все интервалы в стандартной библиотеке полуоткрытые)

 ![image-20230318204345227](media/image-20230318204345227.png)

Здесь мы вставляем луч элементов второго списка в первый в самое начало.

Таким образом,

* Простая форма - перемещение одного в другой O(1)

* Средняя форма - откуда-то и до конца O(1)

* Сложная форма - перемещение части в конкретное место O(N)

> Лучше проверять на эксперименте splice, ибо все время забывается интерфейс.

Применение:

1. В многопоточной среде итераторы не инвалидируются
2. Перевязка, напрмиер в LRU cache

## Адаптеры

![image-20230318210706837](media/image-20230318210706837.png)

![image-20230318211217834](media/image-20230318211217834.png)

Адаптеры - ужатые с точки зрения интерфейса контейнеры - для удобства.

priority_queue построена на векторе, т.к. по алгоритмы в бинарной куче нужно много прыгать, т.е. random_access требуется за O(1).

Применение:

* алгоритм Прима для построения остовного дерева.

> Остовное дерево - все вершины соединены минимальным числом ребер.

* UNIX sort при слянии отсортированных частей

> Почему адаптер стэк не использует контейнер односвязный список?
>
> Нету интерфейса `push_back / pop_back`.

## Контейнеро-подобные классы

### Битовые маски

Никогда не используется `std::array<bool>` . Он не оптимизирован.

Используйте `std::bitset<mask_size>`. 