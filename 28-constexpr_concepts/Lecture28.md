# Lecture 28

## Constraints

![image-20230322093700940](media/image-20230322093700940.png)

`requires` - означает проверку выражения на этапе компиляции. Если они выполнены, то инстанцирование происходит. Это есть "входные ворота" к инстанцированию. Оно зависит от `T, U`.

`is_equality_comparable` - проверка на операции эквивалентности.

Засчет SFINAE, отсутствие подходящего шаблона на этапе инстанцирования не ошибка. Но в случае с `requires` это не так.

### Проблема ODR

![image-20230322094731618](media/image-20230322094731618.png)

В красном случае значения по умолчанию не входят в манглирование, а значит первые две функции с точки зрения перегрузки идентичны. Получаем ошибку. Ее можно исправить так:

```c++
template <typename T, enable_if_t<(sizeof(T) > 4)>* = nullptr>
void foo(T x) { /* ... */ }

template <typename T, enable_if_t<(sizeof(T) <= 4)>* = nullptr>
void foo(T x) { /* ... */ }
```

Или использовать requires. Он входит в манглирование.

### Недостатки `requires`

![image-20230322212409914](media/image-20230322212409914.png)

`is_base_of<Base, Derived>` - возвращает true, если `Base` is base of `Derived`.

 ![image-20230322212326729](media/image-20230322212326729.png)

По реализации `std::random_access_iterator_tag` наследует реализацию `std::input_iterator_tag`. Поэтому все, что удовлетворяет второй функции, также удовлетворяет первой. Но для `requires` не реализована приоритетность или отношение порядка. Поэтому код для `my_distance` выдаст ошибку. 

## `Requires requires`

![image-20230322213532030](media/image-20230322213532030.png)

У `requires` две функции:

* Ограничение инстанцирования при использовании statement - ограничивает инстанцирование (превращает SFINAE в ошибку компиляции)
* `requires expression` - выражение, которое проверяет SFINAE условие, но в отличие от `constexpr`не выполняет предикат, а проверяет его семантическую корректность.

> SFINAE if: выражение либо ДА, либо провал подстановки
>
> Requires if: если expression семантически возможен, то он возвращает true, иначе - false



![image-20230322214336712](media/image-20230322214336712.png)

В первом случае проверяется `14 == 42`

Во втором случае проверяется валиднсть выражения `int == int`. При этом само выражение не выполняется.

![image-20230322214629163](media/image-20230322214629163.png)

## Концепты

Концепт - булев предикат на этапе компиляции.

Чем он лучше той же `constexpr bool foo(cond);`?

Преимущество в том, что концепт можно складывать коньюктивными или дезъюнктивными условиями, представленными либо классическими SFINAE-конструкциями, либо requires-подобными.

![image-20230322215440289](media/image-20230322215440289.png)

`convertible_to` не ошибочен, если определен static_cast (первое условие), и конвертация работает корректно. Принятие ссылки на функцию позволит избежать негативных `lval` эффектов.

![image-20230322222633906](media/image-20230322222633906.png)

 После того, как концепт определен, он может быть использован внутри `requires`.

Requires-requires-requires не совсем эквивалентен вызову одного requires. В обоих случаях идет проверка на bool, но в первом мы имеем комплексный предикат вида `(valid && true)?`, т.е. выражение семантически валидно и оно удовлетворяет концепту. Это утверждение эквивалентно более лаконичной записи со стрелочкой (второй пункт).

Концепты могут быть *составными*. Сами концепты применимы под `requires`.

![image-20230322224606333](media/image-20230322224606333.png)

WeaklyEqualityComparable проверяет, что существуют семантические конструкциями с операторами, и их результат конвертируем в bool. Заметим, что каждый statement со стрелочкой является конъюнктом.

Далее мы этот концепт используем в requires.

![image-20230322225030258](media/image-20230322225030258.png)

Структура, удовлетворяющая концепту:

![image-20230322225217290](media/image-20230322225217290.png)

Структура, не удовлетворяющая концепту (`struct S`):

![image-20230322225231344](media/image-20230322225231344.png)

**Важно. Для концептов не существует специализации! То, что изображено ниже, не является специализацией. Это совершненно новый концепт.**

![image-20230322225542598](media/image-20230322225542598.png)

Сокращенные записи концептов:

![image-20230322230457981](media/image-20230322230457981.png)

```
template <std::input_iterator Iter>
<==>
template <typename Iter>
requires std::input_iterator<Iter>
```

А еще можно вот так:

```
std::input_iterator auto x; // все что угодно, являющееся input_iterator
```

35:28

