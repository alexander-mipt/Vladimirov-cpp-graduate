Тип - значение + диапазон значений + имя (value type) + множество разрешенных опеаций (object type)

```
CHAR_BIT - макрос, содержащий число бит в байте.
CHAR - минимальный адресуемый регион памяти, и все в языках С,С++ измеряется в char, а не байтах. 
Просто так исторически сложилось что 1байт = 8бит = 1char.
```

```
0 - int
NULL - (void*) 0
nullptr - single nullptr_t value
```

ссылка - `lvalue reference` - возможность присвоить значению помимо имени самой переменной еще одно имя. Т.е. ссылка - возможность создать несколько имен у значения.
**Единожды связанную ссылку нельзя перевязать.**
**Ссылку на ссылку сделать нельзя**, ибо ссылка = имя, оно не хранится в памяти (не является реальной сущностью).
Также нельзя сделать указатель на ссылку (но можно сделать ссылку на указатель):
```C++
	int& *ptr_on_ref; // error
	int* &ref_on_ptr; // ok
```

Указатель в отличие от ссылки требует памяти (под него выделяется память). Это большой плюс. Таким образом, ссылки можно использовать для сокращения имен (добавляем к объекту новое более короткое имя.)
```
int &internal = object.somewhere[5].something.internal;
```
Ссылки позволяют сократить число рантайм проверок.
> this - указатель чисто по историческим причинам

## Константность для указателей и ссылок
```C++
int val{0};
const int& c_ref = val; // error
/*
В ссылках возможно только два варианта:
	константная ссылка на константные данные: const int c_ref = const_val;
	обычная ссылка на обычные данные: int ref = val;
*/
```

## Инварианты
Инвариант - то, что остается неизменным на протяжении времени жизни объекта. На практике это означает то, на что мы расчитываем при работе с объектом. Как следствие, оно не требует наличия повторяющихся проверок. Нередко это существенно упрощает алгоритмы.

Для существования и поддержки инвариантов была придумана инкапсуляция. Ее можно реализовать на С.
> Это можно сделать с помощью скрытой реализации, т.е. поместив ее в отдельный модуль, а в заголовочнике лишь продекларировать структуры и функции, работающие с этими структурами.
Минусы:
* Нет инлайна
* Трудно выделять на стэке

В С++ для этого используется специальный оптимизированный механизм.
> Доступ к private полям на уровне интерфейса всегда можно получить хаком, приведя адрес указателя на объект к `char*`.
Однако такие действия потенциально могут нарушить инвариантность класса, а потому никто в здравом уме так не поступает. Это выстрел себе в ногу.

**Использование ссылок позволяет также сохранять инварианты и, как следствие, предотвращает хак с указателями.**

> Лучше всегда использовать геттеры и сеттеры для инкапсуляции (даже если тип содержит одно поле).
```C++
class P {
	int x{0};
public:
	int get_x() const { return x; }
	void set_x(int xval) { x = xval; }
};

struct O {
	int x;
};

int main() {
	O obj;
	int *px = &obj.x;
	delete px; // ha-ha

	P obj2;
	int *px2 = &obj2.x; // error
}
```

## Конструкторы и деструкторы
Они служат начальными условиями для состояния объекта, что позволяет сразу при рождении определить его инварианты, а потом удалить их. `malloc & free` умеют инициализировать структуры данных, но никак не работают с инвариантами. Потому созданы специальные аллокаторы: `new & delete`
> `new[]` перед данными в памяти хранит число объектов. Оно используется оператором `delete`.

## Scope & время жизни
Декларация заканчивается до первого инициализатора. Время жизни начинается после всех инициализаторов.
**Не рекомендуется использовать в классах члены ссылки. Это чревато их провисанием при динамической инициализации объектов соотв. класса.**
> Ссылки не надо возвращать или хранить. Их нужно брать и использовать.

**Временный объект живет до конца полного выражения.**

## `lvalue, rvalue`
### in C
```C
y = x;
```
lvalue - left value
rvalue - right value

### in C++
lvalue - located value (has mem)
rvalue - value without location (has no mem)

## cdecl
```C
char *(*(&c)[10])(int *&p);
// ссылка на массив из указателей на фуннкции: char* f(int* &p)
```

> Для борьбы с cdecl придуман `typedef`, однако он не поддерживает шаблоны. Потому лучше использовать `using`.


