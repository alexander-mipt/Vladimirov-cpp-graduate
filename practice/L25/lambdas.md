# Lecture 25

## Lambdas

Почему лямда это не функция, а класс? Потому что у функция требует памяти под указатель, тогда как лямбда - нет.

```C++
// lambda
[capture_list] (args_list) -> return_type
// "(...)" and "-> return_type" can be ommited
```



![image-20221216232912679](media/image-20221216232912679.png)

`_k` - захват, захваченное состояние.

**В лямбдах захват копируется.**

По умолчанию захват имеет const qualifier. Если мы хотим менять состояние - явно пишем `mutable`.

![image-20221216232933205](media/image-20221216232933205.png)

Глобальные и статические переменные и так видны в лямбде.

```C++
[a](){} // захват по значению
[&a](){} // захват по ссылке (сама ссылка immutable, но то, на что она ссылается - да.)

```

![image-20221216233315857](media/image-20221216233315857.png)

![image-20221216233331559](media/image-20221216233331559.png)

> Почему адреса нельзя захватить по ссылке - потому что lval нельзя присвоить rval.

Захват с перемещением

![image-20221216233552782](media/image-20221216233552782.png)

Захват в теле класса

![image-20221216233614375](media/image-20221216233614375.png)

![image-20221216233741340](media/image-20221216233741340.png)

Задача на closure

**Важно помнить, что лямбда - это скорее класс с перегруженным оператором () **.

![image-20221216235540411](media/image-20221216235540411.png)

21, 52, 72, 106

У нас внутри функции одно определение класса, в котором один перегруженный оператор круглые скобки.

![image-20221216235936247](media/image-20221216235936247.png)

Проблема поля класса, инициализированного лямбдой:

![image-20221217001001478](media/image-20221217001001478.png)

![image-20221217001918226](media/image-20221217001918226.png)

Параметр `std::function` - тип возвращаемого значения и аргументы функции. Она позволяет обощать лямбды по catch_lists 

*Наблюдается общность с таблицей виртуальных функций*

![image-20221217003432391](media/image-20221217003432391.png)

![image-20221217004407847](media/image-20221217004407847.png)

Классная техника. Но в ней есть один недостаток - std::function иниициализирует данные на куче - это небесплатно относительно следующего...

Мы могли бы занести action в шаблонн, но тогда при специализации указание лямбды породило бы класс

# Алгоритмы

![image-20221217005459636](media/image-20221217005459636.png)