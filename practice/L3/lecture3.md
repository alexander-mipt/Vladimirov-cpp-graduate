# livetime & scope
> Провисшие указатели - это очень опасная ошибка

Константные ссылки умеют продлевать жизнь временным объектам.
```C++
const int &lr = 0; // сформирует объект на стеке
```
> Не использовать в классах членах ссылок! Это потенциальные проблемы.

# Манглирование
Гарантия по именам есть только в С. В С++ для возможности перегрузок, неймспейсов и прочее используется **манглирование**. Отключить интерфейс можно с помощью `extern "C"`

```C++
extern "C" int foo(int);
```

## Правила разрешения перегрузок
Точное совпадение (+ `int --> const int&`, ...)?
Точное совпадение с шаблоном (int --> T)?
Совпадение при стандартных преобразованиях типов?
Переменное число аргументов?
Неправильно связанные ссылки (literal --> int&, ...)?

В файле overload.cc конфликт будет возникать в том случае, если на перегрузку будут пртендовать **одинаковые по правам** функции.

## Перегрузка конструкторов

```C++
class A {
	int m_x{0};
public:
	A::A(int x = 0) : m_x(x) {/* ... */} // хороший тон, если одно поле (более локально и меньше строк кода)
}
```

## namespace
Структуры и классы тоже определяют пространство имен.
Пространство имен есть **всегда** (глобальное пространство имен ::)
```C++
int x;

int foo() {
	return ::x;
}
```
На макросы пространство имен не распространяются.
Заголовочники для поддержки пространства имен в стандартной библиотеке были переписаны.
```C++
#include <cstdio> // std::atoi();
#include "stdio.h" // atoi();
```
В простарнство имен можно запихивать из другого:
```C++
namespace X {
	int foo();
}

using std::vector;
```

Анонимные пространства имен
```
namespace {
	int a;
	int foo()
}
...
```
преобразуется в:
```
namespace pdvinpvom {
	...
}
using pdvinpvom; 
```
что эквивалентно использованию `static`
```C++
static int a;
static int foo();
```

* Не засорять глоб. пр. имен
* Никогда не писать using namespace  в заголовочниках
* Не использовать анонимные пространства имен в заголовочных файлах

